<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>db_fds.fdfuncs &#8212; DB-FDs 0.3.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=4621528c"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for db_fds.fdfuncs</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>

<span class="c1">#########################</span>
<span class="c1">### Class Definitions ###</span>
<span class="c1">#########################</span>
<div class="viewcode-block" id="Symbol">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.Symbol">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Symbol</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for the smallest element of Functional Dependency logic. Use this to represent relation attributes.</span>
<span class="sd">    Name should be unique: Two Symbols with the same `name` will return `True` when checked with equality `==`.</span>
<span class="sd">    Other comparisons are also done by `name`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        name (str): Name of the attribute/symbol. This is the main representation.</span>
<span class="sd">        desc (str, optional): Alternative descriptor, used with `Symbol::otherrep`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new `Symbol` with a name and description.</span>

<span class="sd">        Args:</span>
<span class="sd">            name (str): Attribute name. Should be unique for the `Symbol`.</span>
<span class="sd">            desc (str, optional): Attribute description.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">desc</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">name</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;&lt;&#39; not supported between instances of &#39;Symbol&#39; and &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;&lt;=&#39; not supported between instances of &#39;Symbol&#39; and &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&#39; not supported between instances of &#39;Symbol&#39; and &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;=&#39; not supported between instances of &#39;Symbol&#39; and &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="Symbol.otherrep">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.Symbol.otherrep">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">otherrep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alternative representation of the `Symbol` using its description.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">description</span></div>
</div>


<div class="viewcode-block" id="FunctionalDependency">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.FunctionalDependency">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FunctionalDependency</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to represent a functional dependency (FD) between two sets of attributes.</span>
<span class="sd">    Two FDs are equal if their LHS (`fro`) are equal and their RHS (`to`) are equal.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        fro (set[Symbol]): Set of attributes that determine another set of attributes.</span>
<span class="sd">        to (set[Symbol]): Set of attributes that is determined by `fro`.</span>
<span class="sd">        lhs (set[Symbol]): Alias for `fro`.</span>
<span class="sd">        rhs (set[Symbol]): Alias for `to`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fro</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">to</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new `FunctionalDependency` from and to the given `Symbol(s)`.</span>

<span class="sd">        Args:</span>
<span class="sd">            fro (Symbol or set[Symbol]): Left-Hand Side of the dependency.</span>
<span class="sd">            to (Symbol or set[Symbol]): Right-Hand Side of the dependency.</span>
<span class="sd">        </span>
<span class="sd">        Examples:</span>
<span class="sd">            Assuming `Symbol`s A and B are created:</span>
<span class="sd">            &gt;&gt;&gt; A = Symbol(&quot;A&quot;)</span>
<span class="sd">            &gt;&gt;&gt; B = Symbol(&quot;B&quot;)</span>

<span class="sd">            &gt;&gt;&gt; fd1 = FunctionalDependency(A, B)</span>
<span class="sd">            A --&gt; B</span>

<span class="sd">            &gt;&gt;&gt; fd2 = FunctionalDependency({A, B}, B)</span>
<span class="sd">            AB --&gt; B</span>

<span class="sd">            &gt;&gt;&gt; fd2 = FunctionalDependency(B, {A, B})</span>
<span class="sd">            B --&gt; AB</span>

<span class="sd">            &gt;&gt;&gt; fd3 = FunctionalDependency({A}, {B})</span>
<span class="sd">            A --&gt; B</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fro</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fro</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">fro</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fro</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">fro</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">to</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">to</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fro</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rhs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">fro</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fro</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">fro_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fro</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">fro_attr</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">to_attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="n">to_attr</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fro</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot; --&gt; &quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
    
<div class="viewcode-block" id="FunctionalDependency.otherrep">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.FunctionalDependency.otherrep">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">otherrep</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alternative representation of the FD using `Symbol::otherrep`.&quot;&quot;&quot;</span>

        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">otherrep</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fro</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;} --&gt; {&quot;</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">otherrep</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;}&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>
</div>



<span class="c1">##########################</span>
<span class="c1">### Armstrong&#39;s Axioms ###</span>
<span class="c1">##########################</span>
<div class="viewcode-block" id="get_reflexive">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.get_reflexive">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_reflexive</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets all FDs derived from Armstrong&#39;s Axiom of Reflexivity.</span>

<span class="sd">    Args:</span>
<span class="sd">        lhs_attrs (Symbol or set[Symbol]): Attribute(s) to get reflexive FDs from. This set will appear on the LHS of all returned FDs.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: All derived Functional Dependencies.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the function encounters anything in `lhs_attrs` that is not a `Symbol`.</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        Given attributes `ABC`, it can determine any subset of `ABC`.</span>
<span class="sd">        &gt;&gt;&gt; get_reflexive({A, B})</span>
<span class="sd">        {AB --&gt; A, AB --&gt; B, AB --&gt; AB}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">lhs_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only Symbols allowed as input.&quot;</span><span class="p">)</span>
        <span class="n">lhs_attrs</span> <span class="o">=</span> <span class="n">lhs_attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
        <span class="n">lhs_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="n">lhs_attrs</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only Symbols allowed as input.&quot;</span><span class="p">)</span>
    <span class="n">output</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FunctionalDependency</span><span class="p">(</span><span class="n">lhs_attrs</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs</span><span class="p">)))</span>
    
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="get_augmented">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.get_augmented">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_augmented</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="n">FunctionalDependency</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">],</span> <span class="n">others</span><span class="p">:</span> <span class="n">Symbol</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets all FDs derived from Armstrong&#39;s Axiom of Augmentation.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (FunctionalDependency or set[FunctionalDependency]): Set of dependencies to augment.</span>
<span class="sd">        others (Symbol or set[Symbol]): `Symbol`s to augment `fds` with.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Derived Functional Dependencies, excluding the original(s).</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If the function encounters invalid types.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        Given FD `A --&gt; B` returns `Ax --&gt; Bx` for all `x` combinations in `others`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="n">fds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="p">{</span><span class="n">fds</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` is of an invalid type.&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`others` contains type other than Symbol: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">)))</span>
        <span class="n">others</span> <span class="o">=</span> <span class="n">others</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
        <span class="n">others</span> <span class="o">=</span> <span class="p">{</span><span class="n">others</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`others` is on an invalid type.&quot;</span><span class="p">)</span>
    
    <span class="n">output</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">others</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
                <span class="n">frocpy</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">tocpy</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">:</span>
                    <span class="n">frocpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="n">tocpy</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FunctionalDependency</span><span class="p">(</span><span class="n">frocpy</span><span class="p">,</span> <span class="n">tocpy</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="get_transitive">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.get_transitive">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_transitive</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gets all FDs derived from Armstrong&#39;s Axiom of Transitivity.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (set[FunctionalDependency]): Set of dependencies to check.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Derived dependencies, not including the inputs.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If any type other than `FunctionalDependency` encountered in the input.</span>
<span class="sd">    </span>
<span class="sd">    Example:</span>
<span class="sd">        Given FDs `A --&gt; B` and `B --&gt; C`, returns `A --&gt; C`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">output</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">checklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">checklist</span><span class="p">:</span>
        <span class="n">fromfd</span> <span class="o">=</span> <span class="n">checklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tofd</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">seen</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fromfd</span> <span class="o">==</span> <span class="n">tofd</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">fromfd</span><span class="o">.</span><span class="n">to</span> <span class="o">&amp;</span> <span class="n">tofd</span><span class="o">.</span><span class="n">fro</span><span class="p">:</span>
                <span class="n">newfd</span> <span class="o">=</span> <span class="n">FunctionalDependency</span><span class="p">(</span><span class="n">fromfd</span><span class="o">.</span><span class="n">fro</span><span class="p">,</span> <span class="n">tofd</span><span class="o">.</span><span class="n">to</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">newfd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newfd</span><span class="p">)</span>
                    <span class="n">checklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newfd</span><span class="p">)</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newfd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="make_decomposed">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.make_decomposed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_decomposed</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="n">FunctionalDependency</span> <span class="o">|</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a decomposed set of FDs from the input.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (FunctionalDependency or set[FunctionalDependency]): Set of FDs to decompose.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Decomposed FDs, as well as any from the input that were already in a decomposed form.</span>
<span class="sd">            Does not include FDs that were identified as non-decomposed.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If any type other than `FunctionalDependency` encountered in the input.</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; make_decomposed({A --&gt; B, B --&gt; CD})</span>
<span class="sd">        {A --&gt; B, B --&gt; C, B --&gt; D}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span>
        <span class="n">fds</span> <span class="o">=</span> <span class="p">{</span><span class="n">fds</span><span class="p">}</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span> <span class="c1"># type: ignore</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` is of invalid type.&quot;</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FunctionalDependency</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="make_union">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.make_union">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_union</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a set of FDs with the Rule of Union applied.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (FunctionalDependency or set[FunctionalDependency]): Set of FDs to apply union to.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: All FDs that were either\n</span>
<span class="sd">            a) Were not used in any union (already in most combined form).\n</span>
<span class="sd">            b) Result of a union.\n</span>
<span class="sd">            Does not include FDs that produced a new FD by union.</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If `fds` contains a type other than FunctionalDependency.</span>
<span class="sd">    </span>
<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; make_union({A --&gt; B, A --&gt; C, B --&gt; D})</span>
<span class="sd">        {B --&gt; D, A --&gt; BC}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fds</span>
    <span class="n">unique_lhs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">output</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="n">unique_lhs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">lhs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">lhs</span> <span class="ow">in</span> <span class="n">unique_lhs</span><span class="p">:</span>
        <span class="n">new_fd</span><span class="p">:</span> <span class="n">FunctionalDependency</span> <span class="o">=</span> <span class="n">FunctionalDependency</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lhs</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">fd</span><span class="o">.</span><span class="n">rhs</span><span class="p">:</span>
                <span class="n">new_fd</span><span class="o">.</span><span class="n">rhs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_fd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output</span></div>



<span class="c1">###############</span>
<span class="c1">### Closure ###</span>
<span class="c1">###############</span>
<div class="viewcode-block" id="compute_closure">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.compute_closure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_closure</span><span class="p">(</span><span class="n">attrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the closure of a set of attributes with respect to the given FDs.</span>
<span class="sd">    The closure is defined as the set of attributes that can be determined from the input attributes using the FDs.</span>

<span class="sd">    Args:</span>
<span class="sd">        attrs (set[Symbol]): The set of :class:`~fdfuncs.Symbol`\s to compute closure for.</span>
<span class="sd">        fds (set[FunctionalDependency]): FDs to use for closure.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[Symbol] The closure.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If input sets contain unexpected types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`attrs` contains type other than Symbol: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">att</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">att</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span>

    <span class="n">activated</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">attrs</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">remaining_fds</span> <span class="o">=</span> <span class="n">fds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">num_activated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">to_remove</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">remaining_fds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fd</span><span class="o">.</span><span class="n">fro</span> <span class="o">&lt;=</span> <span class="n">activated</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="p">:</span>
                    <span class="n">activated</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                    <span class="n">num_activated</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="n">remaining_fds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">num_activated</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining_fds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">activated</span></div>



<div class="viewcode-block" id="minimal_cover">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.minimal_cover">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">minimal_cover</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the minimal cover / basis of a set of FDs.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (set[FunctionalDependency]): Initial set of FDs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Minimal basis of input FDs.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: Via `make_decomposed`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># 1. Decompose</span>
    <span class="n">working_fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_decomposed</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
    <span class="c1"># print(working_fds)</span>

    <span class="c1"># 2. Clean LHS for redundant</span>
    <span class="n">fds_to_replace</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">replacement_fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">working_fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">redundant_atts</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="p">:</span>
            <span class="n">other_atts</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">other_atts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
            <span class="n">other_fds</span> <span class="o">=</span> <span class="n">working_fds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">other_fds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">other_att_closure</span> <span class="o">=</span> <span class="n">compute_closure</span><span class="p">(</span><span class="n">other_atts</span><span class="p">,</span> <span class="n">other_fds</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">other_att_closure</span><span class="p">:</span>
                <span class="n">redundant_atts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
        
        <span class="c1"># Mark reduns</span>
        <span class="n">new_fd</span><span class="p">:</span> <span class="n">FunctionalDependency</span> <span class="o">=</span> <span class="n">FunctionalDependency</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">redundant_atts</span><span class="p">:</span>
            <span class="n">new_fd</span><span class="o">.</span><span class="n">fro</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">att</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fd</span> <span class="o">!=</span> <span class="n">new_fd</span><span class="p">:</span>
            <span class="n">fds_to_replace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
            <span class="n">replacement_fds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_fd</span><span class="p">)</span>
    
    <span class="c1"># Replace marked LHS attrs</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds_to_replace</span><span class="p">:</span>
        <span class="n">working_fds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">replacement_fds</span><span class="p">:</span>
        <span class="n">working_fds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="c1"># print(working_fds)</span>

    <span class="c1"># 3. Remove redun FDs</span>
    <span class="n">final_fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="n">working_fds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">working_fds</span><span class="p">:</span>
        <span class="n">final_fds</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
        <span class="n">non_fd_closure</span> <span class="o">=</span> <span class="n">compute_closure</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">fro</span><span class="p">,</span> <span class="n">final_fds</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">((</span><span class="n">fd</span><span class="o">.</span><span class="n">to</span> <span class="o">&amp;</span> <span class="n">non_fd_closure</span><span class="p">)</span> <span class="o">==</span> <span class="n">fd</span><span class="o">.</span><span class="n">to</span><span class="p">):</span> <span class="c1"># ==&gt; Not redundant, add back</span>
            <span class="n">final_fds</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">final_fds</span></div>


<div class="viewcode-block" id="canonical_cover">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.canonical_cover">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">canonical_cover</span><span class="p">(</span><span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">],</span> <span class="n">minimum_cover</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span> <span class="c1"># type: ignore</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the canonical cover / basis of a set of FDs.</span>
<span class="sd">    Note: Canonical cover is equivalent to the minimal cover with the Union Rule applied.</span>

<span class="sd">    Args:</span>
<span class="sd">        fds (set[FunctionalDependency]): Initial set of FDs.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Canonical basis of input FDs.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: Via `minimal_cover`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">minimum_cover</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># type: ignore</span>
        <span class="n">minimum_cover</span> <span class="o">=</span> <span class="n">minimal_cover</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">make_union</span><span class="p">(</span><span class="n">minimum_cover</span><span class="p">)</span></div>


<span class="c1">####################</span>
<span class="c1">### Normal Forms ###</span>
<span class="c1">####################</span>

<div class="viewcode-block" id="all_subset_closures">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.all_subset_closures">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">all_subset_closures</span><span class="p">(</span><span class="n">attrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the closure for all attribute subsets.</span>

<span class="sd">    Args:</span>
<span class="sd">        attrs (set[Symbol]): Full set of attributes to compute on.</span>
<span class="sd">        fds (set[FunctionalDependency]): Set of FDs to calculate closure using.</span>
<span class="sd">    Returns:</span>
<span class="sd">        dict[frozenset[Symbol], set[Symbol]]: Dictionary containing closure of every attribute subset combination.\n</span>
<span class="sd">            Note that the key is a frozenset due to hashing limitations.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If input sets contain unexpected types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`attrs` contains type other than Symbol: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">att</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">att</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span>

    <span class="n">out</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
            <span class="n">comb</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">out</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_closure</span><span class="p">(</span><span class="n">comb</span><span class="p">,</span> <span class="n">fds</span><span class="p">)</span> <span class="c1"># type: ignore</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="find_superkeys">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.find_superkeys">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_superkeys</span><span class="p">(</span><span class="n">attrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds all superkeys of a relation.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        attrs (set[Symbol]): Set of attributes in the relation.</span>
<span class="sd">        fds (set[FunctionalDependency]): Set of FDs of the relation.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[frozenset[Symbol]]: Set containing a list of all attribute combinations that act as superkeys for the relation.\n</span>
<span class="sd">            Note that it must be a set of frozensets due to hashing limitations.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: If input sets contain unexpected types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">att</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`attrs` contains type other than Symbol: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">att</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">att</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">fd</span> <span class="ow">in</span> <span class="n">fds</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">FunctionalDependency</span><span class="p">):</span> <span class="c1"># type: ignore</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`fds` contains type other than FunctionalDependency: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">fd</span><span class="p">)))</span>

    <span class="n">all_closures</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="n">all_subset_closures</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">fds</span><span class="p">)</span>
    <span class="n">keys_found</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">all_closures</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">all_closures</span><span class="p">[</span><span class="n">comb</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">attrs</span> <span class="o">==</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">keys_found</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">keys_found</span></div>


<div class="viewcode-block" id="find_keys">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.find_keys">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_keys</span><span class="p">(</span><span class="n">superkeys</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]:</span> <span class="c1"># type: ignore</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds all candidate keys (or just keys) for a relation. </span>
<span class="sd">    This is a set of minimal superkeys, i.e. removing an attribute from any subset in this list makes it no longer a key.\n</span>
<span class="sd">    **IMPORTANT**: Either `superkeys` or both of (`attrs`, `fds`) must be provided. If `superkeys` is provided, other arguments </span>
<span class="sd">    will be ignored.</span>

<span class="sd">    Args:</span>
<span class="sd">        superkeys (set[frozenset[Symbol]], optional): A set of superkeys for the relation. If not provided, superkeys will first be computed from `attrs` and `fds`.</span>
<span class="sd">        attrs (set[Symbol], optional): Set of attributes in the relation.</span>
<span class="sd">        fds (set[FunctionalDependency]): Set of FDs of the relation.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[frozenset[Symbol]]: Set containing a list of all attribute combinations that act as candidate keys for the relation. Note that it must be a set of frozensets due to hashing limitations.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: Via `find_superkeys`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">superkeys</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span> <span class="c1"># type: ignore</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least on of (superkeys) or (attrs and fds) must be provided&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">superkeys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># type: ignore</span>
        <span class="n">superkeys</span> <span class="o">=</span> <span class="n">find_superkeys</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">fds</span><span class="p">)</span>
    <span class="n">superkeys</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">superkeys</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)</span>
    <span class="n">keys_found</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="n">superkeys</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_found</span><span class="p">):</span> <span class="k">break</span>
        <span class="n">to_check</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">keys_found</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">to_remove</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_found</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">to_check</span> <span class="o">&amp;</span> <span class="n">keys_found</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">to_check</span><span class="p">:</span>
                <span class="c1"># keys_found[j] fully encompasses i and has extra: remove it</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">keys_found</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="n">keys_found</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">keys_found</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="non_trivial_n_decomposed">
<a class="viewcode-back" href="../../index.html#db_fds.fdfuncs.non_trivial_n_decomposed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">non_trivial_n_decomposed</span><span class="p">(</span><span class="n">attrs</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Symbol</span><span class="p">],</span> <span class="n">fds</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all &#39;non-trivial and decomposed&#39; Functional Dependencies:\n</span>
<span class="sd">    * Non-Trivial: If a Symbol exists on the LHS of an FD, it will not appear on the RHS.</span>
<span class="sd">    * Decomposed: All RHS will only contain a single Symbol.</span>

<span class="sd">    Any FDs not in the initial arguments will be derived.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        attrs (set[Symbol]): Set of attributes in the relation.</span>
<span class="sd">        fds (set[FunctionalDependency]): Set of FDs of the relation.</span>
<span class="sd">    Returns:</span>
<span class="sd">        set[FunctionalDependency]: Set of all non-trivial and decomposed FDs.</span>
<span class="sd">    Raises:</span>
<span class="sd">        TypeError: Via `all_subset_closures`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">subsets_clsrs</span> <span class="o">=</span> <span class="n">all_subset_closures</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">fds</span><span class="p">)</span>
    <span class="n">out</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">FunctionalDependency</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">subsets_clsrs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">right_attr</span> <span class="ow">in</span> <span class="n">subsets_clsrs</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">right_attr</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">out</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">FunctionalDependency</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">right_attr</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">out</span></div>


<span class="c1"># def check_bcnf_quick(attrs: set[Symbol], fds: set[FunctionalDependency]) -&gt; tuple[bool, FunctionalDependency]:</span>
<span class="c1">#     subsets_clsrs = all_subset_closures(attrs, fds)</span>
<span class="c1">#     for key in subsets_clsrs.keys():</span>
<span class="c1">#         if subsets_clsrs[key] &amp; key == subsets_clsrs[key]:</span>
<span class="c1">#             continue</span>
<span class="c1">#         elif subsets_clsrs[key] &amp; attrs == attrs:</span>
<span class="c1">#             continue</span>
<span class="c1">#         else:</span>
<span class="c1">#             return False, FunctionalDependency(set(key), subsets_clsrs[key])</span>
<span class="c1">#     return True, None # type: ignore</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;fd_solver: Nothing to do here!&quot;</span><span class="p">)</span>
    <span class="n">exit</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">DB-FDs</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Mmaimer33.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>